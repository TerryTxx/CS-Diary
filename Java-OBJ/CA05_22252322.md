[Continuous Assignment project 02](#continuous-assignment-02)

### Simple Factory (add a diagram.draw file and draw if you wish):
![Simple Factory.png](https://github.com/TerryTxx/CS-Diary/blob/master/Java-OBJ/pics%2FSimple%20Factory.png)
https://drive.google.com/file/d/1W_M2EG-ms6pA91XbW4GBHufvSx1FNH9C/view?usp=sharing
- parallel hierarchies
```text
The simple factory in the picture above is the simplest. Generally it not require parallel hierarchies.
This problem can be found in the factory method pattern. 
like Different pizzas have different types, handle different types of orders, and have corresponding different factories.
```
[1. go to factory method to see the parallel hierarchies](#factory-method--add-a-diagramdraw-file-and-draw-if-you-wish--)
[2. go to abs mehtod to find the parallel hierarchies](#abstract-factory--add-a-diagramdraw-file-and-draw-if-you-wish--)

- factory method - how it works to create a product (minimal yet sufficient code/explanation)
```text
Please check the following code. I use the 'createPizza' method to implement the simple factory pattern to create 
and return different types of Pizza objects based on the passed parameter orderType. 
This method checks the orderType, instantiates the corresponding Pizza subclass, sets the corresponding name, and returns the object.
The process is as follows:
1. calls the createPizza method and passes a string of the specified type (such as "greek", "cheese" or "pepper").
2. Inside the method, the string is checked through a series of if-else statements to determine the type of Pizza to be created.
3. Once the Pizza type is determined, the factory method instantiates the corresponding subclass and sets its name.
4. The created Pizza object is returned to the client.
```
```java
package order;
import pizza.*;

//Simple factory class
public class SimpleFactory {
    //Return the corresponding Pizza object according to orderType
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        System.out.println("Use simple factory patten");
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName("GreekPizza");
        } else if (orderType.equals("cheese")) {
            pizza = new CheesePizza();
            pizza.setName("CheesePizza");
        } else if (orderType.equals("pepper")) {
            pizza = new PepperPizza();
            pizza.setName("PepperPizza");
        }
        return pizza;
    }
}
```

- Product and 'concrete' Product
```text
Yes, in the code, the concepts of Product and ConcreteProduct are reflected in the Pizza class and its subclasses (such as CheesePizza, GreekPizza, PepperPizza, etc.).

Product: The corresponding code is the Pizza class. It defines the public interface of the object. The Pizza class defines prepare, bake, cut, box and other methods, but there is no specific implementation.

Concrete Product: The code corresponds to the concrete class inherited from the Pizza class, such as CheesePizza, GreekPizza, PepperPizza, etc. These concrete classes implement various methods of the Pizza class and provide product-specific behavior.

In the OrderPizza class, a specific Pizza object is generated by calling the createPizza method of SimpleFactory. This process hides the creation logic of the ConcreteProduct object. The client only knows that it can obtain the Pizza object through the factory. 
```
```java
package order;
import pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class OrderPizza {

    //Define a simple factory object
    SimpleFactory simpleFactory;
    Pizza pizza = null;

    //Constructor
    public OrderPizza(SimpleFactory simpleFactory) {
        setFactory(simpleFactory);
    }

    public void setFactory(SimpleFactory simpleFactory) {
        String orderType = ""; //User input

        this.simpleFactory = simpleFactory; //Set a simple factory object

        do {
            orderType = getType();
            pizza = this.simpleFactory.createPizza(orderType);

        //output pizza
            if(pizza != null) { //Order successful
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            } else {
                System.out.println("Failed to order pizza");
                break;
            }
        } while (true);
    }

    //Write a method to get the type of pizza the customer wants to order
    private String getType() {
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("input pizza type:");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        }
    }
}

public class PizzaStore {

    public static void main(String[] args) {
//Use simple factory mode
        new OrderPizza(new SimpleFactory());
        System.out.println("~~Exit the program~~");
    }
}
```
- How to identify this variant of factory as distinct from another
```text
Simple Factor: More of a programming habit. There is a separate SimpleFactory class that determines which Product class to instantiate. In the code, SimpleFactory creates concrete Pizza objects, which is closer to the simple factory pattern.

Factory Method: Defines an interface for creating objects, but lets subclasses decide which class to instantiate. Factory Method causes the instantiation of a class to be deferred to its subclasses. In the code behind, there is a subclass that inherits SimpleFactory to decide which Pizza class to instantiate. This is the factory method pattern.

Abstract Factory: Provides an interface for creating a series of related or interdependent objects without specifying their specific classes. In the code behind, SimpleFactory is part of multiple factory classes, and the collection of these factory classes creates a series of related Pizza objects. This is the abstract factory pattern.
```

### Static Factory (add a diagram.draw file and draw if you wish):
- parallel hierarchies
- [1. go to factory method to see the parallel hierarchies](#factory-method--add-a-diagramdraw-file-and-draw-if-you-wish--)
- [2. go to abs mehtod to find the parallel hierarchies](#abstract-factory--add-a-diagramdraw-file-and-draw-if-you-wish--)
- factory method - how it works to create a product (minimal yet sufficient code/explanation)
```text
The createPizza2 method in the code is a factory method;
1. calls StaticSimpleFactory.createPizza2 and passes a string parameter orderType, indicating the type of Pizza you want to create.
2. A series of if-else statements are used inside the method to check orderType to determine the type of Pizza requested by the client.
3. Based on the value of orderType, the method will instantiate the corresponding Pizza subclass and set its name through the setName method.
4. Finally, the method returns the specific Pizza instance created.
```
```java
package order
import pizza.*;

//static factory mode
public class StaticSimpleFactory {
    //static modification makes calling more convenient
    public static Pizza createPizza2(String orderType) {
        Pizza pizza = null;
        System.out.println("Use simple factory mode 2");
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName("GreekPizza");
        } else if (orderType.equals("cheese")) {
            pizza = new CheesePizza();
            pizza.setName("CheesePizza");
        } else if (orderType.equals("pepper")) {
            pizza = new PepperPizza();
            pizza.setName("PepperPizza");
        }
        return pizza;
    }
}
```
- Product and 'concrete' Product
```text
1. Product : Pizza class represents the abstract concept of product. It defines all the behaviors that a specific pizza should have, such as prepare, bake, cut, box, but does not implement these behaviors.

2. ConcreteProduct: Concrete Pizza subclasses, such as GreekPizza, CheesePizza, PepperPizza, etc., represent specific products. They are the concrete implementation of Pizza and provide the actual logic of Pizza's behavior.

In the OrderPizza2 class, create an instance of ConcreteProduct through the static factory method SimpleFactory.createPizza2. Does not interact with ConcreteProduct directly, but through the Product interface.
```
```java
package order;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import pizza.Pizza;

public class OrderPizza2 {
     Pizza pizza = null;
     String orderType = "";
     //Constructor
     public OrderPizza2() {
         do {
             orderType = getType();
             pizza = SimpleFactory.createPizza2(orderType);//Call directly using the class name, no need to pass the object
             // Output pizza
             if (pizza != null) { // Order successful
                 pizza.prepare();
                 pizza.bake();
                 pizza.cut();
                 pizza.box();
             } else {
                 System.out.println("Failed to order pizza");
                 break;
             }
         } while (true);
     }

     private String getType() {
         try {
             BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
             System.out.println("input pizza type:");
             String str = strin.readLine();
             return str;
         } catch (IOException e) {
             e.printStackTrace();
             return "";
         }
     }
}
public class PizzaStore {

	public static void main(String[] args) {
		new OrderPizza2();
	}
}

```
- How to identify this variant of factory as distinct from Simple Factory
```text
In the simple factory pattern, the factory is usually a class with non-static methods, which requires you to instantiate the factory class first, and then call the method to create the product through this instance.

In the static factory pattern, the method of creating a product is static and can be called directly through the class name without first creating an instance of the factory class.

In my code, SimpleFactory.createPizza2 is a static method, which means it belongs to the static factory pattern. The client does not need to create an instance of the factory,
 but directly calls the static method through the class name to create a product instance. This is the main difference between the static factory pattern and the simple factory pattern.
```


### Factory Method (add a diagram.draw file and draw if you wish):
![Factory Method.png](https://github.com/TerryTxx/CS-Diary/blob/master/Java-OBJ/pics%2FFactory%20Method.png)
https://drive.google.com/file/d/1W_M2EG-ms6pA91XbW4GBHufvSx1FNH9C/view?usp=sharing
I have two packages for pizza and order in question two and question three below:
- parallel hierarchies
```text
have two:
Pizza class hierarchy: Pizza is the base class for all concrete pizza classes, and each regional specialty pizza, such as LDPepperPizza, LDCheesePizza, BJPepperPizza, and BJCheesePizza, is a ConcreteProduct in this hierarchy.
(codes below)
OrderPizza class hierarchy: OrderPizza is an abstract class that defines the abstract method createPizza for creating pizza. BJOrderPizza and LDOrderPizza are different implementations of the createPizza method, creating Beijing-style and London-style pizza respectively.
(codes in question 3)
```
```java
package pizza;

public abstract class Pizza {
     protected String name; //name

     //Prepare raw materials, different pizzas are different, therefore, we make an abstract method
     public abstract void prepare();

     public void bake() {
         System.out.println(name + "baking;");
     }

     public void cut() {
         System.out.println(name + " cutting;");
     }

     //Pack
     public void box() {
         System.out.println(name + " boxing;");
     }

     public void setName(String name) {
         this.name = name;
     }
}
package pizza;

public class LDPepperPizza extends Pizza{
     @Override
     public void prepare() {
         setName("London pepper pizza");
         System.out.println("London pepper pizza preparation ingredients");
     }
}
package pizza;

public class LDCheesePizza extends Pizza{
     @Override
     public void prepare() {
         setName("London cheese pizza");
         System.out.println("London cheese pizza preparation raw materials");
     }
}
package pizza;

public class PPPepperPizza extends Pizza {
     @Override
     public void prepare() {
         setName("Beijing pepper pizza");
         System.out.println("Beijing pepper pizza preparation raw materials");
     }
}
package pizza;

public class BJCheesePizza extends Pizza {
     @Override
     public void prepare() {
         setName("Beijing cheese pizza");
         System.out.println("Beijing cheese pizza preparation raw materials");
     }
}
```
- factory method - how it works to create a product (minimal yet sufficient code/explanation)
```text
In following code, the factory method pattern is implemented through the createPizza method of the OrderPizza class. This is an abstract method that every concrete factory subclass (such as BJOrderPizza and LDOrderPizza) must implement.

The workflow is as follows:
1. When a customer wants to place an order, they create an instance of a subclass of OrderPizza (such as new BJOrderPizza() or new LDOrderPizza()).
2. This instantiation process will trigger the constructor of OrderPizza, and then call the createPizza method.
3. Because createPizza is abstract, the specific call is the createPizza method rewritten in the subclass. This method will create a specific flavor of Pizza object based on the parameter orderType.
4. The created Pizza object is then processed by a series of methods such as prepare, bake, cut, box, etc.
```
```java
package order;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import pizza.Pizza;

public abstract class OrderPizza {

     //Define an abstract method, createPizza, and let each factory subclass implement it by itself
     abstract Pizza createPizza(String orderType);

     //Constructor
     public OrderPizza() {
         Pizza pizza = null;
         String orderType; // Type of pizza ordered
         do {
             orderType = getType();
             pizza = createPizza(orderType); //Abstract method, completed by factory subclass
             //Output the pizza making process
             if (pizza != null) {
                 pizza.prepare();
                 pizza.bake();
                 pizza.cut();
                 pizza.box();
             } else {
                 System.out.println("Pizza order failed!");
                 break;
             }
         } while (true);
     }
    
     //Write a method to get the type of pizza the customer wants to order
     private String getType() {
         try {
             BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
             System.out.println("input pizza type:");
             String str = strin.readLine();
             return str;
         } catch (IOException e) {
             e.printStackTrace();
             return "";
         }
     }
}
package order;

import pizza.BJCheesePizza;
import pizza.BJPepperPizza;
import pizza.Pizza;

public class BJOrderPizza extends OrderPizza {
     @Override
     Pizza createPizza(String orderType) {
         Pizza pizza = null;
         if (orderType.equals("cheese")) {
             pizza = new BJCheesePizza();
         } else if (orderType.equals("pepper")) {
             pizza = new BPepperPizza();
         }
         return pizza;
     }
}
package order;

import pizza.*;

public class LDOrderPizza extends OrderPizza {
     @Override
     Pizza createPizza(String orderType) {
         Pizza pizza = null;
         if (orderType.equals("cheese")) {
             pizza = new LDCheesePizza();
         } else if (orderType.equals("pepper")) {
             pizza = new LDPepperPizza();
         }
         return pizza;
     }
}
```
- Product and 'concrete' Product
```text
Product: The Pizza class plays the role of product. It is an abstract class that defines behaviors common to all concrete pizzas (such as prepare, bake, cut, box, etc. methods), but does not specifically implement these methods.

Concrete Product): The BJCheesePizza, BJPepperPizza, LDCheesePizza, and LDPepperPizza classes are concrete products. They inherit from the Pizza class and provide concrete implementations of these methods. For example, the BJCheesePizza class implements the prepare method to prepare the ingredients needed to make a Beijing-style cheese pizza. In this way, each specific pizza type has its own specific flavor and preparation process.
```
```java
package pizza;

public abstract class Pizza {
     protected String name; //name

     //Prepare raw materials, different pizzas are different, therefore, we make an abstract method
     public abstract void prepare();

     public void bake() {
         System.out.println(name + "baking;");
     }

     public void cut() {
         System.out.println(name + " cutting;");
     }

     //Pack
     public void box() {
         System.out.println(name + " boxing;");
     }

     public void setName(String name) {
         this.name = name;
     }
}
package pizza;

public class LDPepperPizza extends Pizza{
     @Override
     public void prepare() {
         setName("London pepper pizza");
         System.out.println("London pepper pizza preparation ingredients");
     }
}
package pizza;

public class LDCheesePizza extends Pizza{
     @Override
     public void prepare() {
         setName("London cheese pizza");
         System.out.println("London cheese pizza preparation raw materials");
     }
}
package pizza;

public class PPPepperPizza extends Pizza {
     @Override
     public void prepare() {
         setName("Beijing pepper pizza");
         System.out.println("Beijing pepper pizza preparation raw materials");
     }
}
package pizza;

public class BJCheesePizza extends Pizza {
     @Override
     public void prepare() {
         setName("Beijing cheese pizza");
         System.out.println("Beijing cheese pizza preparation raw materials");
     }
}
```
- How to identify this variant of factory as distinct from Simple/Static Factory
```text
Factory method pattern: Define a method to create objects through an abstract class, and use its subclasses to implement this method concretely to create different products. Each subclass is equivalent to a specific factory, responsible for creating a specific product.

Simple factory pattern: A factory class determines which product to create through a conditional statement in a method based on the parameters passed in. Factory classes are usually non-static and require an instance to be created first.

Static factory pattern: Similar to the simple factory pattern, but the method of creating an object is static and can be called directly through the class name without creating an instance of the factory class.

In my code, the OrderPizza abstract class defines the createPizza abstract method, and the BJOrderPizza and LDOrderPizza classes override this method to create specific Pizza objects, reflecting the factory method pattern.
Unlike this, referring to the simple/static factory pattern code above, I use a separate non-static or static method to handle the object creation logic.
```


### Abstract Factory (add a diagram.draw file and draw if you wish):
![Abstract Factory.png](https://github.com/TerryTxx/CS-Diary/blob/master/Java-OBJ/pics%2FAbstract%20Factory.png)
https://drive.google.com/file/d/1W_M2EG-ms6pA91XbW4GBHufvSx1FNH9C/view?usp=sharing
the pizza package is not changed, same as method factory patten
- parallel hierarchies
```text
Factory hierarchy: AbsFactory is an interface, and BJFactory and LDFactory are the specific implementations of this interface. Each factory class can create Pizza objects of a specific flavor, forming a hierarchy of factories.

Product hierarchy: Pizza is an abstract class, and LDPepperPizza, LDCheesePizza, BJPepperPizza and BJCheesePizza are specific products. They implement the prepare method of the Pizza class, forming a product hierarchy.
```
- factory method - how it works to create a product (minimal yet sufficient code/explanation)
```text
As shown in the following code, the AbsFactory interface defines a createPizza method. 
Concrete factory classes (such as BJFactory and LDFactory) implement this interface and provide a concrete implementation of the createPizza method. 
When an instance of the OrderPizza class is created, it receives a factory object that implements the AbsFactory interface and creates the product by calling the object's createPizza method.
```
```java
package order;

import pizza.Pizza;

//An abstraction layer (interface) of the abstract factory pattern
public interface AbsFactory {
     //Let the following factory subclass implement it concretely
     public Pizza createPizza(String orderType);
}
package order;

import pizza.BJCheesePizza;
import pizza.BJPepperPizza;
import pizza.Pizza;

//This is a factory subclass
public class BJFactory implements AbsFactory {

     @Override
     public Pizza createPizza(String orderType) {
         System.out.println("~Using the abstract factory pattern~");
         Pizza pizza = null;
         if(orderType.equals("cheese")) {
             pizza = new BJCheesePizza();
         } else if (orderType.equals("pepper")){
             pizza = new BPepperPizza();
         }
         return pizza;
     }
}
package order;

import pizza.LDCheesePizza;
import pizza.LDPepperPizza;
import pizza.Pizza;

public class LDFactory implements AbsFactory {
     @Override
     public Pizza createPizza(String orderType) {
         System.out.println("~Using the abstract factory pattern~");
         Pizza pizza = null;
         if (orderType.equals("cheese")) {
             pizza = new LDCheesePizza();
         } else if (orderType.equals("pepper")) {
             pizza = new LDPepperPizza();
         }
         return pizza;
     }
}
package order;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import pizza.Pizza;

public class OrderPizza {

     AbsFactory factory;

     //Constructor
     public OrderPizza(AbsFactory factory) {
         setFactory(factory);
     }

     private void setFactory(AbsFactory factory) {
         Pizza pizza = null;
         String orderType = ""; // User input
         this.factory = factory;
         do {
             orderType = getType();
             // factory may be a factory subclass in Beijing or a factory subclass in London
             pizza = factory.createPizza(orderType);
             if (pizza != null) { // order ok
                 pizza.prepare();
                 pizza.bake();
                 pizza.cut();
                 pizza.box();
             } else {
                 System.out.println("Order failed");
                 break;
             }
         } while (true);
     }

     //Write a method to get the type of pizza the customer wants to order
     private String getType() {
         try {
             BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
             System.out.println("input pizza type:");
             String str = strin.readLine();
             return str;
         } catch (IOException e) {
             e.printStackTrace();
             return "";
         }
     }
}
package order;

public class PizzaStore {

     public static void main(String[] args) {
         //new OrderPizza(new BJFactory());
         new OrderPizza(new LDFactory());
     }
}
```
- Product and 'concrete' Product
```text
The Pizza class is an abstract representation of the product and defines methods common to all pizzas.
LDPepperPizza, LDCheesePizza, BJPepperPizza and BJCheesePizza are concrete products that inherit from Pizza and provide concrete implementations of the prepare method.
```
- How to identify this variant of factory as distinct from Factory Method
```text
The main difference between the Abstract Factory pattern and the Factory Method pattern is that the Abstract Factory pattern uses an interface 
to create a series of related or dependent objects instead of just one object, and there is no need to specify the concrete classes of these objects. 
The Factory Method pattern is typically used to create a single product by letting subclasses decide which class to instantiate. 
In my code, AbsFactory allows the creation of a series of related Pizza products, which represents the Abstract Factory pattern.
```




## Continuous Assignment 02
```text
Continuous homework I made a ABS Factory pattern case according to the week homework;
This case implements the abstract factory pattern for creating pizzas with different flavors. 
It contains a Pizza abstract class and several concrete Pizza subclasses, representing different types of pizza. 
The AbsFactory interface defines a method createPizza for creating pizza. BJFactory and LDFactory are specific implementations of this interface and are used to create Beijing-style and London-style pizza respectively. 
The OrderPizza class receives a factory instance of type AbsFactory and creates pizzas from this instance. 
Finally, the PizzaStore class demonstrates how to use a factory to place an order. 
This case shows how to use the abstract factory pattern to decouple the client and the creation process of specific products.
```
```JAVA
package pizza;

public abstract class Pizza {
     protected String name; //name

     //Prepare raw materials, different pizzas are different, therefore, we make an abstract method
     public abstract void prepare();

     public void bake() {
         System.out.println(name + "baking;");
     }

     public void cut() {
         System.out.println(name + " cutting;");
     }

     //Pack
     public void box() {
         System.out.println(name + " boxing;");
     }

     public void setName(String name) {
         this.name = name;
     }
}
package pizza;

public class LDPepperPizza extends Pizza{
     @Override
     public void prepare() {
         setName("London pepper pizza");
         System.out.println("London pepper pizza preparation ingredients");
     }
}
package pizza;

public class LDCheesePizza extends Pizza{
     @Override
     public void prepare() {
         setName("London cheese pizza");
         System.out.println("London cheese pizza preparation raw materials");
     }
}
package pizza;

public class PPPepperPizza extends Pizza {
     @Override
     public void prepare() {
         setName("Beijing pepper pizza");
         System.out.println("Beijing pepper pizza preparation raw materials");
     }
}
package pizza;

public class BJCheesePizza extends Pizza {
     @Override
     public void prepare() {
         setName("Beijing cheese pizza");
         System.out.println("Beijing cheese pizza preparation raw materials");
     }
}

package order;

import pizza.Pizza;

//An abstraction layer (interface) of the abstract factory pattern
public interface AbsFactory {
     //Let the following factory subclass implement it concretely
     public Pizza createPizza(String orderType);
}
package order;

import pizza.BJCheesePizza;
import pizza.BJPepperPizza;
import pizza.Pizza;

//This is a factory subclass
public class BJFactory implements AbsFactory {

     @Override
     public Pizza createPizza(String orderType) {
         System.out.println("~Using the abstract factory pattern~");
         Pizza pizza = null;
         if(orderType.equals("cheese")) {
             pizza = new BJCheesePizza();
         } else if (orderType.equals("pepper")){
             pizza = new BPepperPizza();
         }
         return pizza;
     }
}
package order;

import pizza.LDCheesePizza;
import pizza.LDPepperPizza;
import pizza.Pizza;

public class LDFactory implements AbsFactory {
     @Override
     public Pizza createPizza(String orderType) {
         System.out.println("~Using the abstract factory pattern~");
         Pizza pizza = null;
         if (orderType.equals("cheese")) {
             pizza = new LDCheesePizza();
         } else if (orderType.equals("pepper")) {
             pizza = new LDPepperPizza();
         }
         return pizza;
     }
}
package order;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import pizza.Pizza;

public class OrderPizza {

     AbsFactory factory;

     //Constructor
     public OrderPizza(AbsFactory factory) {
         setFactory(factory);
     }

     private void setFactory(AbsFactory factory) {
         Pizza pizza = null;
         String orderType = ""; // User input
         this.factory = factory;
         do {
             orderType = getType();
             // factory may be a factory subclass in Beijing or a factory subclass in London
             pizza = factory.createPizza(orderType);
             if (pizza != null) { // order ok
                 pizza.prepare();
                 pizza.bake();
                 pizza.cut();
                 pizza.box();
             } else {
                 System.out.println("Order failed");
                 break;
             }
         } while (true);
     }

     //Write a method to get the type of pizza the customer wants to order
     private String getType() {
         try {
             BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
             System.out.println("input pizza type:");
             String str = strin.readLine();
             return str;
         } catch (IOException e) {
             e.printStackTrace();
             return "";
         }
     }
}
package order;

public class PizzaStore {

     public static void main(String[] args) {
         //new OrderPizza(new BJFactory());
         new OrderPizza(new LDFactory());
     }
}

```